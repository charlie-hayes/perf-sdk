syntax = "proto3";

// See README.md in this directory for a description of these.
package protocol;
option csharp_namespace = "Couchbase.Grpc.Protocol";
option java_package = "com.couchbase.grpc.sdk.protocol";
option go_package = "github.com/couchbaselabs/transactions-fit-performer/protocol";
option java_multiple_files = true;

import "sdk_commands.proto";
import "sdk_basic.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

service PerformerSdkService {

    // Creates a connection between performer and couchbase server
    rpc createConnection (CreateConnectionRequest) returns (CreateConnectionResponse);

    rpc sdkCommand (SdkCreateRequest) returns (SdkCommandResult);

    rpc perfRun (PerfRunRequest) returns (stream PerfSingleSdkOpResult);
}

message CreateConnectionRequest {
    string clusterHostname=1;
    string clusterUsername=2;
    string clusterPassword=3;
}

// Returns the capabilities of the performer (or more specifically, the transactions-implementation-under-test by that
// performer)
message CreateConnectionResponse {
    //repeated PerformerCaps performerCaps = 1;

    // Human-readable string identifying the performer.  For example, "java".
    string performerUserAgent = 1;

    // Identifies the version of the library under test.  For example, "1.1.2".
    string performerLibraryVersion = 2;

    // Defined https://hackmd.io/foGjnSSIQmqfks2lXwNp8w#Protocol-Versions
    // Must be "1.0" or "2.0", any other values will cause the driver to abort.
    string protocolVersion = 3;

    string clusterConnectionId=4;
}

message SdkCreateRequest {
    repeated SdkCommand commands = 1;

    string name = 2;

    string clusterConnectionId=3;
}

message SdkCommandResult {
    SdkException exception=1;
    ExternalException exceptionCause=2;
    repeated string log=3;
}

// "HorizontalScaling" is an abstraction over there been many forms of concurrency.  The core idea is that the driver
// is trying to increase the parallelism, and it's up to the performer to choose a suitable platform-dependent way to
// do this.
// For some languages that will be threads.  For some, a larger pool of concurrent Future/Promises.  For some,
// forking a new process.
// Whatever is produced (thread, new process), it should run the provided transaction in a tight loop.  So essentially
// PerfRunHorizontalScaling is the number of concurrent transactions.
message PerfRunHorizontalScaling {
    // Performer will run these transactions, in a loop.
    repeated SdkCreateRequest sdkCommand = 1;
}

message PerfRunRequest {
    // Optional, allows a custom Cluster connection to be used
    string clusterConnectionId = 1;

    // See PerfRunHorizontalScaling for a discussion of this.  Broadly, it's the number of concurrent transactions
    // required.
    repeated PerfRunHorizontalScaling horizontalScaling = 2;

    // Performer will run until this much time has elapsed.
    // Counted from when it creates the factory, after waiting for the bucket to be opened.
    int32 runForSeconds = 3;
}

message PerfSingleSdkOpResult {
    // Implementations should not provide the logs field here, to conserve memory & bandwidth
    SdkCommandResult results = 1;

    google.protobuf.Timestamp initiated = 2;
    google.protobuf.Timestamp finished = 3;
}